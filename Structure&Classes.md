구조체와 클래스(Structures & Classes)
===
_Structure & Class_ 는 유연한 구조의 Code 구성요소입니다.  
Swift는 사용자정의 Structure와 Class에 대해 별도의 파일을 만들 필요가 없습니다.
단일 파일에 Structure와 Class를 정의면 자동으로 다른 코드에서 사용할 수 있습니다.
## 구조체와 클래스의 비교
### 공통점
+ Value저장을 위한 `Property`정의
+ 기능 제공을 위한 `Method`정의
+ Value에 대한 접근을 제공하는 `Sub Script`정의
+ 초기화 상태 설정을 위한 `초기화`정의
+ 기능정 확장을 위한 `extend`
+ 표준 기능 제공을 위한 `Protocol`준수
### Class의 추가적인 기능
+ 다른 Class의 특성 `상속가능`
+ 인스턴스의 type을 확인하고 해석할 수 있는 `Type Casting`가능
+ 인스턴스가 할당된 리소스 해제를 위한 초기화 해체(``)
+ 참조 카운팅은 하나 이상의 클래스 인스턴스 참조를 허락

## Class & Structure 정의
구조체는 `struct` 클래스는 `class`키워드로 시작하여, 중괄호 안에 전체 정의가 위치합니다.
```swift
struct SomeStructure {
    //전체 정의    
}
class SomeClass {
    //전체 정의
}
```
> Struct/Class를 새로 정의할 떄는 표준 Swift타입과 동일한`UpperCamelCase`를 적용하며, 내부의 프로퍼티나 메서드는 구분을 위해 `lowerCamelCase`를 적용합니다.
## Struct와 Class의 인스턴스
정의된 구조체의 사용을 위해서는 인스턴스가 필요합니다.
초기화 구문을 통해 Struct/Class의 새로운 인스턴스를 생성할 수 있습니다.
```swift
//모든 프로퍼티가 기본값으로 초기화 되는 인스턴스 생성
let someS = someStructure()
let someC = someClass()
```
### 프로퍼티 접근
_점 구문_ 을 사용하여 인스턴스의 프로퍼티에 접근할 수 있습니다.
<small>점 구문은 인스턴스이름 뒤에 `.`구분자로 분리하고 공백없이 프로퍼티 이름을 작성합니다.
```swift
someS.someProperty = 30
someC.someProperty = "test"
```

### Structure 자료형에 대한 멤버별 초기화 구문
모든 구조체는 새로운 인스턴스의 멤버 프로퍼티를 초기화 할때 사용할 수 있는 _멤버별 초기화 구문_ 을 가지고 있습니다.
```swift
Struct Resolution = {
    var width = 0
    var height = 0
}
let vga = Resolution(width : 640, height : 480)
```
> Structure와 반대로 Class는 멤버별 초기화를 사용하지 않습니다.

## 초기화
<small>_초기화_ 는 인스턴스의 클래스,구조체,열거형을 사용하지 위해 준비하는 단계이며 _초기화 구문_ 을 정의하여 구현합니다.

이때 인스턴스에 멤버 프로퍼티의 초기값을 설정하고 새로운 인스턴스가 사용할 준비가 되기 전에 다른 설정이나 초기화를 수행하는것을 포함합니다.  

Class 인스턴스는 인스턴스가 할당 해제되기 전에 정리를 수행하는 _초기화 해제_ 를 구현 할 수 있습니다.</small>

### 저장된 프로퍼티에 초기값 설정
Class와 Struct는 인스턴스가 생성될 떄 까지 모든 저장된 프로퍼티에 적절한 초기값이 반드시 설정되어있어야 합니다.

#### 초기화 구문
<small>_초기화 구문_ 은 새로운 인스턴스를 생성하기위해 호출됩니다.  
`init`키워드를 사용하여 파라미터가 없는 인스턴스 메서드와 같은 형식으로 사용할 수 있습니다.</small>
```swift
init(){
    초기화 실행
}
//예시
struct Fahrenheit{
    var temp : Double
    init(){
        temp = 32.0
    }
}
var f = Fahrenheit()
f.temp // init으로 초기화된 32.0
```

#### 기본 프로퍼티 값
프로퍼티가 항상 같은 초기값을 가지는 경우 초기화 구문이 아닌 선언에 가까운 방식으로 프로퍼티의 초기화를 수행할 수 있습니다.
```swift
struct Fahrenheit{
    var temp = 32.0
}
```
### 사용자 초기화 구문
초기화 중에 상수 프로퍼티 할당으로 초기화 단계를 사용자화 할 수 있습니다.
#### 초기화 파라미터
초기화의 정의의 부분으로 초기화 단계를 사용자화 하는 값의 타입과 이름을 정의하기 위해 제공할 수 있습니다.
```swift
//예시
struct Celsius{
    var tempInCelsius : Double
    //초기화 파라미러를 사용한 두가지 초기화 구문
    init(fromFahrenheit fahrenheit: Double){
        tempInCelsius = (fahrenheit - 32.0)/1.8
    }
    init(fromKelvin kelvin : Double){
        tempInCelsius = kelvin - 273.15
    }
}
let boilingPointOfWater = Celsius(fromFahrenheit : 212.0)
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
```
첫번째 초기화 구문은 인자 라벨`fromFahrenheit`와 파라미터 명 `fahrenheit`을 가지는 초기화 파라미터가 사용되었고, 두번째 초기화 구문은 인자라벨 `fromKelvin`과 파라미터명 `kelvin`을 가진 초기화 파라미터가 사용되었습니다.
#### 파라미터 명과 인자 라벨
초기화 파라미터는 초기화 구문 호출을 위한 `인자 라벨` 초기화 구문 바디내에서 사용되는 `파라미터 명`을 가질 수 있으나, 식별 함수 이름을 가질 수는 없습니다.
따라서 초기화 구문의 식별을 위해 `인자 라벨`과 `파라미터 명`의 사용이 중요합니다.

특히 Swift에서는 사용자가 제공하지 않아도 초기화 구문에서 모든 파라미터에 대한 `인자 라벨`을 자동으로 제공하며 인자 라벨을 사용하지 않고 초기화 구문을 호출 할 수 없습니다.
```swift
//예시
struct Color {
    let red,green,blue: Double
    init(red:Double,green:Double,blue:Double){
        self.red = red
        self.green = green
        self.blue = blue
    }
    init(white:Double){
        red = white
        green = white
        blue = white
    }
}
let magenta = Color(red:1.0, green:0.0, blue:1.0)
let halfGray = Color(white:0.5)
let veryGreen = Color(0.0, 1.0, 0.0)//인자 라벨을 사용하지 않아 에러 발생
```

초기화 구문 파라미터에 인자 라벨 사용을 원지 않을 경우 명시적으로 인자 라벨 대신 `_` 을 작성하여 재정의해야 합니다.
```swift
struct Celsius{
    var tempInCelsius : Double
    init(_ celsius:Double){
        tempInCelsius = celsius
    }
}
let bodyTemp = Celsius(37.0)//인자 라벨 없이 초기화
```
#### Optional 프로퍼티 타입
Optional 타입으로 프로퍼티를 선언 할 수 있으며 명시적으로 초기화 하지 않을 경우 기본적으로 `nil` 값으로 초기화 됩니다.
```swift
class SurveyQuestion{
    var test : String
    var response : String?
    init(text:String){
        self.text = text
    }
    func ask(){
        print(text)
    }
}
let cheeseQ = SurveyQuestion(text:"Do you like Chesse?")
chesseQ.response //nil값
cheeseQ.ask()
chesseQ.response = "Yes" //
```
#### 초기화 프로퍼티 상수 할당
초기화 진행시에는 상수로 할당된 프로퍼티에 Value를 한번 할당 할 수 있습니다.
> Class 인스턴스의 경우 상수 프로퍼티를 상속받은 하위 클래스에서는 프로퍼티를 수정할 수 없습니다.

### 기본 초기화 구문
Swift는 모든 프로퍼티에 대한 기본값을 제공하며,초기화 구문을 하나도 지원하지 않는 모든 Struct와 Class에 대해 _기본 초기화 구문_ 을 제공합니다.

기본 초기화 구문은 모든 프로퍼티가 기본값으로 설정된 새로운 인스턴스를 생성합니다.
```swift
//기본 초기화 구문 예시
class ShoppingListItem{
    var name : String?
    var quantity = 1
    var purchased = false
}
var item = ShoppingListItem()
//name : nil, quantity : 1, purchased : false인 class 생성
```
#### Struct에 대한 멤버별 초기화 구문
Struct는 사용자화 초기화 구문을 정의하지 않으면 자동으로 _멤버별 초기화 구문_ 을 받습니다. Struct는 기본값을 가지지 않은 멤버 프로퍼티라도 멤버별 초기화 구문을 받습니다.

멤버별 초기화 구문은 멤버 프로퍼티를 초기화하기 위한 짧은 구문이며, 새로운 인스턴스의 프로퍼티를 위한 초기화 값을 이름으로 전달 받습니다.
```swift
struct Size{
    var width = 0.0, height = 0.0
}
//구조체 Size는 자동으로 새로운 인스턴스 초기화를 위해 사용할 수 있는 초기화 구문 init(width:height:)을 받습니다.
let twoByTwo = Size(width : 2,0, height : 2.0)
```

멤버별 초기화 구문을 호출할때 기본값이 존재하는 프로퍼티의 값은 생략 할 수 있습니다.

#### 값타입을 위한 초기화 구문 위임
여러 초기화 구문에서 코드가 중복되는 것을 방지하기 위해 초기화 구문은 인스턴스의 초기화의 일부를 수행하기 위해 다른 초기화 구문을 호출하는 _초기화 구문 위임_ 을 실행 할 수 있습니다.

초기화 구문 위임의 동작 방식과 허용 형식은 값 타입(Struct,Enum)과 클래스 타입에 따라 다릅니다. 값 타입은 상속을 지원하지 않고 초기화 구문 위임 과정은 자신이 제공하는 다른 초히과 구문에만 위임할 수 있으므로 비교적 간단합니다. 클래스는 상속이 가능하기 때문에 하위클래스의 프로퍼티의 초기화에 대한 책임이 있습니다.

값 타입에서 초기화 구문을 작성 할 때 같은 값 타입으로 부터 다른 초기화 구문을 참조하기위해 `self.init`을 사용합니다. `self.init`은 초기화 구문 내에서만 호출 할 수 있습니다.

값 타입에 대한 사용자 초기화 구문이 정의되면 그타입 에서 멤버별 초기화 구문에 접근 할 수 없습니다. 자동 초기화 구문 사용을 통한 필수 설정 우회가 방지 됩니다.
```swift
struct Size {
    var width = 0.0, height = 0.0
}
struct Point {
    var x = 0.0,y=0.0
}
struct Rect {
    var origin = Point()
    var size = Size()
    init(){}
    init(origin: Point, size: Size){
        self.origin = origin
        self.size = size
    }
    init(center:Point,size:Size){
        let originX = center.x - (size.width /2)
        let originY = center.y - (size.height/2)
        self.init(origin : Point(x:originX, y: originY),size:size)
    }
}
```
### 클래스 상속과 초기화
상위 클래스로부터 상속받은 클래스의 모든 프로퍼티를 포함하는 모든 클래스의 멤버 프로퍼티는 초기화중에 반드시 초기값이 할당되어야 합니다.

Swift에서는 모든 프로퍼티에 초기값을 설정할 수 있도록 Class에 대해 _Designated Initializer(지정된 초기화 구문)_ 와 _Convenience Initializer(편의 초기화 구문)_ 을 제공합니다.

#### Class의 2가지 초기화 구문
___지정된 초기화 구문(Designated Initializer)___ 은 Class의 주 초기화 구문으로 해당 Class에 의해 도입된 모든 프로퍼티를 완벽하게 초기화 하고 적절한 상퀴 클래스 초기화를 호출하여 상위 클래스 체인까지 초기화 과정을 지속합니다.

모든 클래스는 적어도 하나의 지정된 초기화 구문을 가지고 있어야 하며, 경우에 따라서는 상위클래스에서 하나 이상의 지정된 초기화 구문을 상속하는 것으로 충족시킬 수 있습니다.

___편의 초기화 구문(convenience initializer)___ 는 Class에 대한 초기화 구문을 지원하는 보조 초기화 구문입니다. 지정된 초기화 구문의 파라미터를 기본값으로 설정하여 편의 초기화구문과 동일한 Class에서 지정된 초기화 구문을 호출하도록 정의할 수 있습니다. 특정 사용 케이스 또는 입력 값 타입에 대한 해당 클래스의 인스턴스를 생성 하기 위해 편의 초기화 구문을 지정할 수 있습니다.

초기화 패턴에 대한 시간을 절약하거나 클래스 초기화를 명확하기 하기위해 편의 초기화 구문을 생성합니다.

#### Class 초기화 구문 문법
지정 초기화 구문을 값타입의 간단한 초기화 구문과 동일하게 작성됩니다.
```swift
init(파라미터){
    초기화 구문
}
```
편의 초기화 구문은 `convenience`키워드를 사용하여 작성됩니다.
```swift
convenience init(파라미터){
    구문
}
```
#### Class에 대한 초기화 구문 위임
초기화 구문 사이의 관계를 단순화 하기위해 초기화 사이의 위임 호출에 대한 3가지 규칙을 적용합니다.
1. 지정된 초기화 구문은 상위 클래스로부터 지정된 초기화 구문을 호출해야 합니다.
2. 편의 초기화 구문은 _같은_ 클래스의 다른 초기화 구문을 호출해야 합니다.
3. 편의 초기화 구문은 궁극적으로 지정된 초기화 구문을 호출해야 합니다.
단순화 한 방법은 아래와 같습니다.
+ 지정된 초기화 구문은 항상 위로 위임해야 합니다.
+ 편의 초기화 구문은 항상 옆으로 위임해야 합니다.

#### 2단계 초기화 구문
Swift에서 Class의 초기화는 2단계 프로세스입니다. 

1단계에서는 각 멤버 프로퍼티가 해당 프로퍼티를 도입한 Class에 의해 초기값이 할당됩니다.

2단계에서는 초기화를 안전하게 수행하는 동시에 계층도의 각 Class에 완전한 유연성을 제공합니다. 2단계 에서는 초기화되기 전에 프로퍼티값에 접근하는것을 막고 다른 초기화 구문이 예기치않게 다른 값을 설정하는것을 막습니다.

Swift의 컴파일러는 에러없이 2단계가 완료되었는지 확인하기위해 4가지 검사를 수행합니다.

__안전 점검 1단계__  
지정된 초기화 구문은 상위 클래스 초기화 구문에 위임되기 전에 클래스의 멤버 프로퍼티가 모두 초기화 되었는지 확인합니다.  
__안전 전검 2단계__
지정 초기화 구문은 상위 클래스에 의해 초기화 구문에 할당된 값이 덮어씌워지는 것을 막기 위해 상속된 프로퍼티에 값을 할당하기 전에 상위 클래스 초기화 구문에 위임해야 합니다.
__안전 점검 3단계__
편의 초기화 구문에 할당한 새로운 값이 자체 클래스의 지정된 초기화 구문에 의해 덮어씌워지는 것을 막기위해 _모든_ 프로퍼티에 값을 할당하기 전에 다른 초기화 구문에 위임해야 합니다.
__안전 점검 4단계__
초기화 구문은 첫번째 초기화가 완료되기 전까지 인스턴스 메서드를 호출하거나 인스턴스 프로퍼티의 값을 읽거나 `self`를 참조할 수 없습니다.

안전 점검을 기반으로한 2단계 초기화 프로세스
__1단계__
+ 지정된 편의 초기화 구문을 Class에서 호출됩니다.
+ 클래스에 새로운 인스턴스에 대한 메모리가 할당됩니다. 아직 초기화 되지 않습니다.
+ 클래스에 대한 지정 초기화 구문은 클래스의 모든 멤버 프로퍼티가 값을 가지고 있는지 확인합니다. 멤버 프로퍼티에 대한 메모리는 초기화 됩니다.
+ 지정 초기화 구문은 멤버 프로퍼티에 동일한 작업을 수행하기 위해 상위 클래스 초기화 구문에 전달 됩니다.
+ 최상위 체인까지 클래스 상속 체인 위로 계속 됩니다.
+ 최상위 체인에 마지막 클래스가 모든 멤버 프로퍼티가 값을 가지고 있다고 확인하면 인스턴스 메모리가 완벽하게 초기화 되었다고 간주하고 1단계를 완료합니다.
__2단계__
+ 쳬인의 최상위에서 아래로 내려가면서 각 초기화 구문은 인스턴스를 추가로 사용자 정의할 수있는 옵션이 있습니다. 초기화 구문은 `self`로 접근할 수 있으며 프로퍼티를 수정할 수 있고 인스턴스 메서드를 호출하는 등의 작업을 수행할 수 있습니다.
+ 마지막으로 체인의 모든 편의화 구문은 인스턴스를 사용자 정의하고 `self`로 작업할 수 있는 옵션이 있습니다.
#### 초기화 구문의 상속과 재정의
Swift의 하위 클래스는 기본적으로 상위 Class의 초기화 구문을 상속하지 않습니다. Swift에서는 상위 클래스의 간단한 초기화 구문이 더 특별한 일을 하기 위한 하위 클래스 상속되어 올바르게 초기화 되지 않은 하위 클래스의 새로운 인스턴스를 생성하기 위해 사용되는 상황을 방지합니다.
> 상위 클래스 초기화 구문은 안전하고 적절한 경우에만 상속됩니다.  

상위클래스에 _지정 초기화구문_ 과 일치하는 하위 클래스 초기화 구문을 작성할 떄 지정 초기화 구문의 재정의를 효과적으로 제공합니다.
하위 클래스의 초기화 구문 정의 전에 `override`수식어 작성이 필요합니다.

`override`수식어가 있으면 Swift가 상위 클래스에 재정의 할 일치하는 지정 초기화 구문이 있는지 확인하고 재정의할 초기화 구문의 파라미터가 의도한대로 지정되었는지 확인해야합니다.
> 하위 클래스에서 _편의 초기화 구문_ 사용해도 상위 클래스에 지정된 초기화 구문을 재정의 할때 항상 `override` 수식어를 작성합니다.

반대로 상위 클래스에서 _편의 초기화 구문_ 과 일치하는 하위 클래스 초기화 구문을 작성하는 경우 해당 상위클래스의 편의 초기화 구문은 하위 클래스에서 직접적으로 호출될 수 없습니다. 따라서 하위 클래스는 상위클래스 초기화 구문에 재정의를 재공하지 않습니다.
결론적으로 상위 클래스 편의 초기화 구문의 일치하는 구현을 제공할 때는 `override`수식어를 작성하지 않습니다.
#### 자동 초기화 구문 상속
기본적으로 하위 클래스는 상위 클래스 초기화 구문을 상속하지 않습니다. 그러나 특정 조건을 충족하면 상위 클래스 초기화 구문이 자동으로 하위 클래스에게 상속됩니다. 이러한 자동 상속으로인해 초기화 구문 재정의를 작성할 필요가 없어지고 최소한의 노력으로 상위 클래스의 초기화 구문을 안전하게 상속 할 수 있습니다.

하위 클래스에 도입한 멤버 프로퍼티에 기본값을 제공하면 2가지 규칙이 적용됩니다.
1. 하위 클래스가 지정 초기화 구문을 정의하지 않았으면 자동으로 상위 클래스에서 모든 지정 초기화 구문을 상속합니다.
2. 규칙 1에 따라 상속하거나 정의의 부분으로 사용자 정의 구현을 제공하여 모든 상위 클래스의 지정 초기화 구문의 구현을 제공하면 모든 상위 클래스의 초기화 구문을 자동으로 상속합니다.
